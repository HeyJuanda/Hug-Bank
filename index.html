<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="bank.png" />
    <title>Hug-Bank! • Tu Banco Digital</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* [Se mantiene todo el bloque de estilos CSS] */
        :root {
            --hug-primary: #007bff;
            --hug-secondary: #ffffff;
            --hug-text-color: #1f2937;
            --hug-header: #3b82f6;
        }

        body {
            font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacs, sans-serif;
            background-color: var(--hug-secondary);
            color: var(--hug-text-color);
            max-width: 100%;
            max-height: 60%;
        }
        .bg-card {
            background-color: #ffffff;
            border-radius: 1rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        .btn-primary {
            background-color: var(--hug-primary);
            transition: background-color 0.2s ease-in-out;
        }
        .btn-primary:hover {
            background-color: #2563eb; /* Blue-600 */
        }
        .btn-secondary {
            background-color: #e5e7eb; /* Gray-200 */
            color: var(--hug-text-color);
            transition: background-color 0.2s ease-in-out;
        }
        .btn-secondary:hover {
            background-color: #d1d5db;
        }
        .transaction-item:hover {
            background-color: #f7f9fb;
        }
        .header-bar {
            background-color: var(--hug-header);
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 0.75rem 0.75rem 0 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        /* Estilos para el modal/overlay */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }
        .modal-content {
            background-color: #fefefe;
            margin: 15% auto;
            padding: 20px;
            border-radius: 0.5rem;
            width: 80%;
            max-width: 400px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .close-btn {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }
        .close-btn:hover,
        .close-btn:focus {
            color: #000;
            text-decoration: none;
            cursor: pointer;
        }
        .star-rating label {
            font-size: 2rem;
            color: #ccc;
            cursor: pointer;
        }
        .star-rating input:checked ~ label {
            color: #ffc107;
        }
        .star-rating input {
            display: none;
        }
        .star-rating {
            direction: rtl;
            display: inline-block;
        }
        .star-rating label:hover,
        .star-rating label:hover ~ label {
            color: #ffc107;
        }

    </style>
</head>
<body class="min-h-screen flex items-start justify-center p-4 md:p-8">

    <div id="app" class="w-full max-w-5xl">
        
        <div id="dashboard-view" class="hidden bg-card p-0">
            
            <div class="header-bar flex flex-col md:flex-row justify-between items-start md:items-center space-y-3 md:space-y-0">
                <div class="flex-shrink-0">
                    <h1 class="text-2xl font-extrabold">
                        <img src="bank.svg" alt="HUG Bank Logo" class="inline h-16 w-16 mr-2 align-middle">
                        <span class="text-white">HUG</span> - <span class="text-blue-200">Bank</span>
                    </h1>
                    <p class="text-sm font-medium mt-1">Bienvenido, <span id="user-name-display" class="font-bold">Usuario</span></p>
                    <p class="text-xs text-blue-200 mt-0 break-all">ID: <span id="user-id-display">...</span></p>
                    <div class="flex items-center space-x-2">
                        <p class="text-xs text-blue-200 mt-0">Crédito: <span id="credit-score-display" class="font-bold text-white">N/A</span></p>
                        <button id="reset-score-btn" class="bg-yellow-400 text-gray-800 text-xs font-bold px-2 py-0.5 rounded hover:bg-yellow-500 transition duration-150" title="Costo: $5.00">
                            Resetear Score
                        </button>
                        </div>
                </div>

                <div class="flex flex-row space-x-4 w-full md:w-auto">
                    <button onclick="window.location.href='business'" class="flex-1 py-2 px-2 rounded-full text-md font-semibold text-white btn-primary">
                        Busisness
                    </button>
                    <button id="show-transfer-btn" class="flex-1 py-2 px-4 rounded-full text-md font-semibold text-white btn-primary">
                        Transferir / Prestar
                    </button>
                    <button id="logout-btn" class="flex-1 py-2 px-4 rounded-full text-md font-semibold btn-secondary">
                        Cerrar Sesión
                    </button>
                </div>
            </div>

            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 p-6 md:p-8">
                
                <div class="lg:col-span-1 space-y-6">
                    
                    <div class="bg-blue-50 p-6 rounded-xl border border-blue-200 text-center">
                        <p class="text-sm text-blue-600">Saldo actual</p>
                        <h3 class="text-4xl font-extrabold mt-1 text-hug-text-color" id="balance-display">$0.00</h3>
                    </div>

                    <div class="bg-card p-5 border border-gray-100">
                        <h3 class="text-xl font-bold mb-4">Deudas y Ofertas</h3>
                        <div id="debts-list" class="space-y-4">
                            <p class="text-gray-500 text-sm">Cargando...</p>
                        </div>
                    </div>
                    
                    <div class="bg-card p-5 border border-gray-100">
                        <h3 class="text-xl font-bold mb-4">Solicitudes de Préstamo Públicas</h3>
                        <div id="loan-requests-list" class="space-y-4 max-h-60 overflow-y-auto">
                            <p class="text-gray-500 text-sm">Cargando solicitudes...</p>
                        </div>
                    </div>
                    </div>

                <div class="lg:col-span-2">
                    <div class="bg-card p-5 border border-gray-100 h-full">
                        <h3 class="text-xl font-bold mb-4">Historial Completo</h3>
                        <div id="transactions-list" class="space-y-3 max-h-96 lg:max-h-[600px] overflow-y-auto pr-2">
                            <p class="text-gray-500 text-sm">Cargando historial...</p>
                        </div>
                    </div>
                </div>

            </div>
        </div>

        <div id="transfer-view" class="hidden bg-card p-6 md:p-8 max-w-md mx-auto mt-16">
            <h2 class="text-2xl font-bold mb-4">Enviar o Prestar</h2>

            <form id="transfer-form" class="space-y-4">
                <div>
                    <label for="recipient-id" id="recipient-id-label" class="block text-sm font-medium">ID del Receptor</label>
                    <input type="text" id="recipient-id" required placeholder="ID completo del usuario"
                           class="mt-1 block w-full px-3 py-2 border rounded-lg focus:ring-blue-500 focus:border-blue-500">
                           </div>

                <div>
                    <label for="amount" class="block text-sm font-medium">Monto</label>
                    <input type="number" id="amount" required min="0.01" step="0.01" placeholder="Ej: 50.00"
                           class="mt-1 block w-full px-3 py-2 border rounded-lg focus:ring-blue-500 focus:border-blue-500">
                </div>
                
                <div>
                    <label for="transaction-type" class="block text-sm font-medium">Tipo de Transacción</label>
                    <select id="transaction-type" class="mt-1 block w-full px-3 py-2 border rounded-lg focus:ring-blue-500 focus:border-blue-500">
                        <option value="transfer">Transferencia</option>
                        <option value="loan">Oferta de Préstamo (Prestar)</option>
                        <option value="loan-request">Solicitud de Préstamo (Deuda)</option>
                    </select>
                </div>
                
                <div>
                    <label for="description" class="block text-sm font-medium">Descripción (Opcional)</label>
                    <input type="text" id="description" placeholder="Referencia o motivo de la transacción"
                           class="mt-1 block w-full px-3 py-2 border rounded-lg focus:ring-blue-500 focus:border-blue-500">
                </div>
                <div id="interest-rate-field">
                    <label for="interest" class="block text-sm font-medium">Interés (%)</label>
                    <input type="number" id="interest" min="5" step="0.01" value="5"
                           class="mt-1 block w-full px-3 py-2 border rounded-lg focus:ring-blue-500 focus:border-blue-500">
                </div>

                <button type="submit" id="transfer-submit-btn" class="w-full py-3 px-4 rounded-full text-lg font-semibold text-white btn-primary">
                    Confirmar
                </button>
            </form>

            <button id="back-to-dashboard-btn" class="w-full mt-4 py-3 px-4 rounded-full text-lg font-semibold btn-secondary">
                Volver
            </button>
        </div>

        <div id="message-box" class="mt-4 p-4 rounded-lg text-sm hidden" role="alert"></div>

    </div>
    
    <div id="score-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn">&times;</span>
            <h3 class="text-xl font-bold mb-4">Puntuar Deudor</h3>
            <p class="mb-4">Califica el comportamiento de pago de <span id="score-modal-recipient-name" class="font-semibold"></span> (ID: <span id="score-modal-recipient-id" class="text-sm"></span>)</p>
            
            <form id="score-form" data-loan-doc-id="" data-recipient-id="">
                 <div class="flex justify-center mb-6">
                    <div class="star-rating">
                        <input type="radio" id="star5" name="rating" value="5" required /><label for="star5" title="5 estrellas">★</label>
                        <input type="radio" id="star4" name="rating" value="4" /><label for="star4" title="4 estrellas">★</label>
                        <input type="radio" id="star3" name="rating" value="3" /><label for="star3" title="3 estrellas">★</label>
                        <input type="radio" id="star2" name="rating" value="2" /><label for="star2" title="2 estrellas">★</label>
                        <input type="radio" id="star1" name="rating" value="1" /><label for="star1" title="1 estrella">★</label>
                    </div>
                 </div>
                <button type="submit" class="w-full py-2 px-4 rounded-full text-md font-semibold text-white btn-primary">
                    Enviar Puntuación
                </button>
            </form>
        </div>
    </div>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        // Se mantiene getAuth, pero solo para signOut y onAuthStateChanged
        import { getAuth, signOut, onAuthStateChanged, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, updateDoc, runTransaction, collection, query, orderBy, onSnapshot, addDoc, serverTimestamp, where, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // --- CONFIGURACIÓN E INICIALIZACIÓN DE FIREBASE ---
        const demoFirebaseConfig = {
            apiKey: "AIzaSyBedGoV0Lp_i0Z2wo1_0SkaJa_NrZTPN2g",
            authDomain: "hug-bank.firebaseapp.com",
            projectId: "hug-bank",
            storageBucket: "hug-bank.firebasestorage.app",
            messagingSenderId: "891285624181",
            appId: "1:891285624181:web:c37e3a50275353af88af3c",
            measurementId: "G-5HDSRH2SBH"
        };
        const firebaseConfig = (typeof __firebase_config !== 'undefined' && __firebase_config) ? JSON.parse(__firebase_config) : demoFirebaseConfig;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        let currentUser = null; 

        // --- REFERENCIAS DE UI ---
        const views = {
            dashboard: document.getElementById('dashboard-view'),
            transfer: document.getElementById('transfer-view')
        };
        const messageBox = document.getElementById('message-box');
        const transactionTypeSelect = document.getElementById('transaction-type');
        const interestRateField = document.getElementById('interest-rate-field');
        const transactionsList = document.getElementById('transactions-list');
        const debtsList = document.getElementById('debts-list'); 
        const creditScoreDisplay = document.getElementById('credit-score-display'); 
        // Referencia UI para el nombre
        const userNameDisplay = document.getElementById('user-name-display');
        
        // [ADICIÓN: Referencias de UI para Solicitudes]
        const loanRequestsList = document.getElementById('loan-requests-list');
        const recipientIdInput = document.getElementById('recipient-id');
        const recipientIdLabel = document.getElementById('recipient-id-label');
        const transferSubmitBtn = document.getElementById('transfer-submit-btn');
        // [/ADICIÓN: Referencias de UI para Solicitudes]
        
        // Referencias de Inputs
        const amountInput = document.getElementById('amount');
        const interestInput = document.getElementById('interest');
        // NUEVO: Referencia para la descripción
        const descriptionInput = document.getElementById('description');


        // Referencias del Modal de Puntuación
        const scoreModal = document.getElementById('score-modal');
        const closeBtn = document.querySelector('.close-btn');
        const scoreForm = document.getElementById('score-form');
        const scoreModalRecipientName = document.getElementById('score-modal-recipient-name');
        const scoreModalRecipientId = document.getElementById('score-modal-recipient-id');


        // --- UTILIDADES ---
        function showMessage(message, type = 'success') {
            messageBox.textContent = message;
            messageBox.className = 'mt-4 p-4 rounded-lg text-sm transition-all duration-300';
            if (type === 'success') {
                messageBox.classList.add('bg-green-100', 'text-green-800');
            } else if (type === 'error') {
                messageBox.classList.add('bg-red-100', 'text-red-800');
            } else if (type === 'info') {
                 messageBox.classList.add('bg-blue-100', 'text-blue-800');
            }
            messageBox.classList.remove('hidden');

            setTimeout(() => {
                messageBox.classList.add('hidden');
            }, 5000);
        }

        function switchView(target) {
            Object.values(views).forEach(view => view.classList.add('hidden'));
            views[target].classList.remove('hidden');
        }
        
        // --- LÓGICA DE INTERÉS MÍNIMO DINÁMICO (CORREGIDO) ---
        
        function getRequiredMinimumInterest(amount) {
            // Comisión: 5% (< $50), 8% ($50 <= x < $250), 10% (>= $250)
            if (amount >= 250) { 
                return 10;
            } else if (amount >= 50) { 
                return 8;
            } else if (amount > 0) {
                return 5;
            }
            return 5; // Default minimum
        }
        
        function updateMinimumInterest() {
            const transactionType = transactionTypeSelect.value;
            // Solo aplica para préstamos y solicitudes de préstamo
            if (transactionType === 'transfer') return; 

            const amount = parseFloat(amountInput.value) || 0;
            
            // Si el monto no es válido o es cero, establecer el mínimo a 5%
            const minInterest = getRequiredMinimumInterest(amount);

            // 1. Actualizar el atributo 'min' del campo de interés
            interestInput.setAttribute('min', minInterest.toString());

            // 2. Si el valor actual es menor que el nuevo mínimo, actualizar el valor
            let currentInterest = parseFloat(interestInput.value) || 0;
            if (currentInterest < minInterest) {
                interestInput.value = minInterest.toString();
            }
        }
        // --- FIN LÓGICA DE INTERÉS MÍNIMO DINÁMICO ---


        // --- LÓGICA DEL MODAL DE PUNTUACIÓN ---
        closeBtn.onclick = () => { scoreModal.style.display = 'none'; };
        window.onclick = (event) => {
            if (event.target === scoreModal) {
                scoreModal.style.display = 'none';
            }
        };

        scoreForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const rating = parseInt(document.querySelector('input[name="rating"]:checked').value);
            const loanDocId = scoreForm.getAttribute('data-loan-doc-id');
            const recipientId = scoreForm.getAttribute('data-recipient-id');
            
            try {
                // 1. Se puntúa la deuda y el deudor
                await saveCreditScore(recipientId, rating);
                // 2. Se marca la transacción de prestamista como puntuado para no volver a salir el botón.
                await updateDoc(doc(db, `artifacts/${appId}/users/${currentUser.uid}/transactions/${loanDocId}`), { 
                    scoreGiven: true, 
                    score: rating 
                });
                
                showMessage('Puntuación enviada con éxito.', 'success');
                scoreModal.style.display = 'none';
                // Recargar el saldo y las transacciones para actualizar la UI
                loadBalance(currentUser.uid);
                listenToTransactions(currentUser.uid); // Forzar recarga de transacciones
            } catch (error) {
                console.error("Error al enviar puntuación:", error);
                showMessage(`Error al enviar puntuación: ${error.message}`, 'error');
            }
        });

        // --- MANEJO DE VISTAS Y EVENTOS ---
        
        document.getElementById('show-transfer-btn').addEventListener('click', () => {
            switchView('transfer');
        });

        document.getElementById('back-to-dashboard-btn').addEventListener('click', () => {
            switchView('dashboard');
        });
        
        // [LISTENER: Ajustar el interés mínimo según el monto al escribir]
        amountInput.addEventListener('input', updateMinimumInterest);

        // [Lógica para ocultar/cambiar inputs en Transferir/Solicitar]
        transactionTypeSelect.addEventListener('change', (e) => {
            const type = e.target.value;
            const isLoanRequest = type === 'loan-request';
            
            // Campo de Interés
            interestRateField.classList.toggle('hidden', type === 'transfer');
            
            // Campo de Receptor
            recipientIdInput.required = !isLoanRequest;
            recipientIdInput.value = isLoanRequest ? '' : recipientIdInput.value;
            recipientIdInput.disabled = isLoanRequest; // Deshabilitar si es solicitud
            recipientIdInput.placeholder = isLoanRequest ? 'Se genera automáticamente' : 'ID completo del usuario';
            recipientIdLabel.textContent = isLoanRequest ? 'ID del Solicitante (Eres tú)' : 'ID del Receptor';
            transferSubmitBtn.textContent = isLoanRequest ? 'Publicar Solicitud' : 'Confirmar';
            
            // Aplicar la lógica de mínimo de interés al cambiar el tipo de transacción
            if (type !== 'transfer') {
                updateMinimumInterest(); 
            } else {
                 interestInput.setAttribute('min', '0'); // Restablecer mínimo para transferencias (aunque está oculto)
            }
        });
        // Inicializar el estado de la vista de transferencia/préstamo
        transactionTypeSelect.dispatchEvent(new Event('change'));
        // [/Lógica para ocultar/cambiar inputs en Transferir/Solicitar]

        // --- FIREBASE AUTH Y ESTADO ---
        
        document.getElementById('logout-btn').addEventListener('click', async () => {
            try {
                await signOut(auth);
                // Redirigir al usuario al login
                window.location.href = './login'; 
            } catch (error) {
                console.error("Error al cerrar sesión:", error);
                showMessage('Error al cerrar sesión.', 'error');
            }
        });

        // Bloque de autenticación
        onAuthStateChanged(auth, async (user) => {
            if (user && !user.isAnonymous) { // Solo usuarios autenticados con cuenta
                currentUser = user;
                document.getElementById('user-id-display').textContent = user.uid;
                
                loadBalance(user.uid);
                loadCreditScore(user.uid); // Cargar puntuación de crédito
                listenToTransactions(user.uid);
                // [ADICIÓN: Escuchar solicitudes de préstamo]
                listenToLoanRequests(user.uid);
                // [/ADICIÓN: Escuchar solicitudes de préstamo]
                switchView('dashboard');
            } else if (user && user.isAnonymous) {
                // Si el usuario es anónimo (solo para entorno), forzar redirección al login
                await signOut(auth);
                window.location.href = './login';
            } else {
                currentUser = null;
                // Si no hay usuario, redirigir al login.
                window.location.href = './login'; 
            }
        });
        
        // [ADICIÓN: Función para resetear el score]
        async function resetCreditScore(userId) {
            if (!userId) return;
            const COST = 5.00;
            const userAccountRef = doc(db, `artifacts/${appId}/users/${userId}/account/data`);
            
            if (!confirm(`Confirmar pago de $${COST.toFixed(2)} para resetear tu historial crediticio a 5.0 ★ (0 votos). ¿Deseas continuar?`)) {
                showMessage('Operación de reseteo de score cancelada.', 'info');
                return;
            }

            try {
                await runTransaction(db, async (transaction) => {
                    const userDoc = await transaction.get(userAccountRef);
                    if (!userDoc.exists()) throw new Error("Cuenta no encontrada.");

                    const currentBalance = userDoc.data().balance;
                    if (currentBalance < COST) throw new Error("Saldo insuficiente para pagar el reseteo.");

                    // Descontar saldo
                    const newBalance = currentBalance - COST;
                    transaction.update(userAccountRef, { 
                        balance: newBalance,
                        creditScore: { average: 5.0, count: 0 } // Resetear score
                    });
                });

                // Registrar transacción en historial (Salida de dinero)
                const userData = await getAccountData(userId);
                await createTransaction(userId, {
                    amount: COST,
                    senderId: userId,
                    recipientId: 'HUG Bank',
                    type: 'score-reset-fee',
                    senderName: userData.name,
                    recipientName: 'HUG Bank'
                }); 

                showMessage('¡Tu historial crediticio ha sido reseteado a 5.0 estrellas! Se descontaron $5.00 de tu saldo.', 'success');
                loadBalance(userId);
                loadCreditScore(userId);
                listenToTransactions(userId);
            } catch (e) {
                console.error("Fallo al resetear el score:", e);
                showMessage(`Fallo al resetear el score: ${e.message}`, 'error');
            }
        }
        
        document.getElementById('reset-score-btn').addEventListener('click', () => {
            if (currentUser) {
                resetCreditScore(currentUser.uid);
            }
        });
        // [/ADICIÓN: Función para resetear el score]


        // --- FUNCIONES FIRESTORE ---
        
        // *** CORRECCIÓN #1: Modificación de loadBalance para cargar el nombre desde Firestore.
        async function loadBalance(userId) {
            if (!userId) return;
            const balanceDisplay = document.getElementById('balance-display');
            try {
                const userAccountRef = doc(db, `artifacts/${appId}/users/${userId}/account/data`);
                const docSnap = await getDoc(userAccountRef);
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    const balance = data.balance;
                    
                    // >> OBTENER Y MOSTRAR EL NOMBRE DESDE FIRESTORE <<
                    userNameDisplay.textContent = data.name || 'Usuario';
                    
                    // Aquí es donde el saldo negativo se mostrará correctamente si aplica
                    balanceDisplay.textContent = `$${balance.toFixed(2)}`;
                } else {
                    // Si llega aquí sin cuenta, debería ser un error, pero forzamos la inicialización
                    // Usamos currentUser.displayName como fallback si está disponible
                    const fallbackName = currentUser.displayName || 'Anónimo'; 
                    await setDoc(userAccountRef, { balance: 0.00, name: fallbackName, email: currentUser.email || 'N/A', creditScore: { average: 5.0, count: 0 } });
                    
                    // >> MOSTRAR EL NOMBRE DE FALLBACK <<
                    userNameDisplay.textContent = fallbackName;
                    
                    balanceDisplay.textContent = '$0.00';
                }
            } catch (error) {
                console.error("Error al cargar el saldo:", error);
                balanceDisplay.textContent = 'Error';
            }
        }
        
        async function loadCreditScore(userId) {
             if (!userId) return;
             try {
                const userAccountRef = doc(db, `artifacts/${appId}/users/${userId}/account/data`);
                const docSnap = await getDoc(userAccountRef);
                if (docSnap.exists() && docSnap.data().creditScore) {
                    const score = docSnap.data().creditScore;
                    const rating = score.average.toFixed(1);
                    creditScoreDisplay.textContent = `${rating} ★ (${score.count})`;
                } else {
                    creditScoreDisplay.textContent = '5.0 ★ (0)';
                }
            } catch (error) {
                console.error("Error al cargar la puntuación de crédito:", error);
                creditScoreDisplay.textContent = 'Error';
            }
        }

        async function getAccountData(userId) {
             const userAccountRef = doc(db, `artifacts/${appId}/users/${userId}/account/data`);
             const docSnap = await getDoc(userAccountRef);
             if (docSnap.exists()) return docSnap.data();
             return null;
        }

        async function createTransaction(userId, transactionData) {
            const transactionsRef = collection(db, `artifacts/${appId}/users/${userId}/transactions`);
            return await addDoc(transactionsRef, { ...transactionData, timestamp: serverTimestamp() });
        }
        
        // --- FUNCIÓN ADICIONAL: Cancelar Préstamo por Prestamista (CON PENALIDAD DEL 5% DEL TOTAL) ---
        async function cancelLoanByLender(lenderTransactionId, recipientId) {
            if (!currentUser) return;
            const lenderId = currentUser.uid;
            
            const lenderRef = doc(db, `artifacts/${appId}/users/${lenderId}/account/data`); // Referencia a la cuenta del prestamista

            // 1. Encontrar el documento 'loan-sent' del prestamista
            const lenderDocRef = doc(db, `artifacts/${appId}/users/${lenderId}/transactions/${lenderTransactionId}`);
            const lenderDocSnap = await getDoc(lenderDocRef);
            if (!lenderDocSnap.exists() || lenderDocSnap.data().status !== 'completed') {
                throw new Error("Transacción del prestamista no válida o no completada.");
            }
            const loanData = lenderDocSnap.data();
            
            // 2. Buscar el documento 'loan-debt' correspondiente del deudor.
            const debtQuery = query(
                collection(db, `artifacts/${appId}/users/${recipientId}/transactions`),
                where('type', '==', 'loan-debt'),
                where('senderTransactionId', '==', lenderTransactionId),
                where('status', 'in', ['pending', 'pending-offer'])
            );
            const debtSnapshot = await getDocs(debtQuery);
            const debtDoc = debtSnapshot.docs.length > 0 ? debtSnapshot.docs[0] : null;
            const debtDocRef = debtDoc ? doc(db, `artifacts/${appId}/users/${recipientId}/transactions/${debtDoc.id}`) : null;

            // 3. Iniciar Transacción
            try {
                // Cálculo de la penalidad: 5% del TOTAL (Capital + Interés)
                const interestRateDecimal = loanData.interestRate / 100;
                const amountToPay = loanData.originalAmount * (1 + interestRateDecimal);
                const penaltyRate = 0.05; // 5% de penalidad para el prestamista
                const penaltyAmount = amountToPay * penaltyRate; // 5% del total (Capital + Interés)

                await runTransaction(db, async (transaction) => {
                    const lenderDoc = await transaction.get(lenderRef);
                    if (!lenderDoc.exists()) throw new Error("Documento de la cuenta del prestamista no existe.");
                    
                    const lenderBalance = lenderDoc.data().balance;

                    // DEDUCCIÓN DE LA PENALIDAD DEL PRESTAMISTA
                    // IMPORTANTE: NO SE HACE CHEQUEO DE SALDO. SE PERMITE SALDO NEGATIVO.
                    const newLenderBalance = lenderBalance - penaltyAmount;

                    // 1. DEDUCIR LA PENALIDAD Y ACTUALIZAR SALDO DEL PRESTAMISTA
                    transaction.update(lenderRef, { balance: newLenderBalance });
                    
                    // 2. Marcar el 'loan-sent' del prestamista como pagado/penalizado
                    transaction.update(lenderDocRef, { 
                        status: 'completed-paid-penalized', // Nuevo estado
                        paidAmount: amountToPay, 
                        paidDate: serverTimestamp(),
                        penaltyAmount: penaltyAmount,
                        scoreGiven: false // El prestamista debe puntuar al deudor después de esta acción
                    });
                    
                    // 3. Marcar el 'loan-debt' del deudor como pagado, si existe.
                    if (debtDocRef) {
                        // El estado 'paid-by-lender' le aparecerá al deudor como "Pagado por Prestamista (Cancelación)"
                        transaction.update(debtDocRef, { status: 'paid-by-lender', paidAmount: amountToPay, paidDate: serverTimestamp() });
                    }
                });

                // 4. Crear transacciones de historial
                const recipientData = await getAccountData(recipientId);
                const lenderData = await getAccountData(lenderId);

                 // A. Registrar la PENALIDAD en el historial del prestamista (Salida de dinero - Negativo)
                await createTransaction(lenderId, {
                    amount: penaltyAmount,
                    senderId: lenderId,
                    recipientId: 'HUG Bank',
                    type: 'lender-cancellation-penalty', // Salida de dinero por penalidad (NEGATIVO)
                    originalLoanId: lenderTransactionId,
                    interestRate: loanData.interestRate,
                    senderName: lenderData.name,
                    recipientName: 'HUG Bank',
                    description: `Penalidad del 5% por cancelación de préstamo a ${recipientData.name}`
                }); 
                
                 // B. Registrar el "cobro" del préstamo en el historial del prestamista (Entrada de dinero por la cancelación)
                await createTransaction(lenderId, {
                    amount: amountToPay,
                    senderId: recipientId, 
                    recipientId: lenderId,
                    type: 'loan-paid-cancellation', // Entrada de dinero (Cobro de préstamo por cancelación - Solo Historial)
                    originalLoanId: lenderTransactionId,
                    interestRate: loanData.interestRate,
                    senderName: recipientData.name,
                    recipientName: lenderData.name,
                    description: `Reembolso Bruto por cancelación de préstamo a ${recipientData.name}`
                }); 
                 // C. Registrar el pago en el historial del deudor (Solo Historial)
                await createTransaction(recipientId, {
                    amount: amountToPay,
                    senderId: lenderId,
                    recipientId: recipientId,
                    type: 'loan-payment-lender-cancellation', 
                    originalLoanId: debtDoc ? debtDoc.id : 'N/A',
                    interestRate: loanData.interestRate,
                    senderName: lenderData.name,
                    recipientName: recipientData.name,
                    description: `Préstamo cancelado y marcado como pagado por ${lenderData.name}`
                }); 

                showMessage(`Préstamo marcado como PAGADO. Se le ha aplicado una penalidad del 5% ($${penaltyAmount.toFixed(2)}) de la deuda total ($${amountToPay.toFixed(2)}) en su saldo. Ahora puedes puntuar al deudor.`, 'success');
                loadBalance(lenderId);
                listenToTransactions(lenderId); // Forzar recarga de transacciones
            } catch (e) {
                console.error("Fallo al cancelar préstamo:", e);
                showMessage(`Fallo al cancelar el préstamo: ${e.message}`, 'error');
            }
        }
        
        // --- FUNCIÓN ADICIONAL: Guardar Puntuación de Crédito ---
        async function saveCreditScore(recipientId, score) {
            if (!currentUser) throw new Error("Usuario no autenticado.");
            
            const recipientAccountRef = doc(db, `artifacts/${appId}/users/${recipientId}/account/data`);

            await runTransaction(db, async (transaction) => {
                const recipientDoc = await transaction.get(recipientAccountRef);
                if (!recipientDoc.exists()) throw new Error("Cuenta del deudor no encontrada.");

                const data = recipientDoc.data();
                const currentScore = data.creditScore || { average: 5.0, count: 0 };
                
                // Nuevo cálculo del promedio
                const newTotal = (currentScore.average * currentScore.count) + score;
                const newCount = currentScore.count + 1;
                const newAverage = newTotal / newCount;

                // Actualizar el perfil del deudor
                transaction.update(recipientAccountRef, { 
                    creditScore: {
                        average: newAverage,
                        count: newCount
                    }
                });
            });
            // Recargar el score del prestamista, en caso de que sea el mismo, aunque no es su score.
            loadCreditScore(recipientId);
        }


        // --- MANEJO DE TRANSFERENCIAS Y PRÉSTAMOS ---
        document.getElementById('transfer-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            if (!currentUser) { showMessage('Debes iniciar sesión para transferir.', 'error'); return; }

            // El recipientId solo es obligatorio si no es una Solicitud de Préstamo
            const recipientId = transactionTypeSelect.value !== 'loan-request' ? document.getElementById('recipient-id').value.trim() : null;
            const amount = parseFloat(document.getElementById('amount').value);
            const transactionType = transactionTypeSelect.value;
            const interest = parseFloat(document.getElementById('interest').value);
            // NUEVO: Extracción de la descripción
            const description = descriptionInput.value.trim();
            const senderId = currentUser.uid;

            if (transactionType !== 'loan-request' && senderId === recipientId) { 
                showMessage('No puedes transferir a tu propia cuenta.', 'error'); return; 
            }
            if (amount <= 0 || isNaN(amount)) { showMessage('Monto no válido.', 'error'); return; }
            
            // VALIDACIÓN: Interés mínimo requerido según el monto (usa la lógica dinámica)
            const minRequiredInterest = getRequiredMinimumInterest(amount);
            if (transactionType !== 'transfer' && interest < minRequiredInterest) { 
                showMessage(`El interés mínimo para este monto es del ${minRequiredInterest}%.`, 'error'); return; 
            }

            if (transactionType === 'loan-request') {
                const interestRate = interest; // Ya está definido como 'interest'
                
                // MODIFICADO: Interés mínimo 5%, máximo 50%
                if (isNaN(interestRate) || interestRate > 50) { 
                    return showMessage('El interés máximo para solicitudes debe ser del 50%.', 'error'); 
                }

                // --- FIX: SOLUCIÓN AL ERROR DEL ÍNDICE (Check de una sola solicitud activa) ---
                // Se busca por un solo campo ('debtorId') para evitar el requisito de índice compuesto.
                const userRequestsQuery = query(
                    collection(db, `artifacts/${appId}/loan-requests`),
                    where('debtorId', '==', senderId)
                );
                
                let hasActiveRequest = false;
                try {
                    const userRequestsSnapshot = await getDocs(userRequestsQuery);
                    // Filtramos en el cliente si existe alguna con estado 'pending'
                    hasActiveRequest = userRequestsSnapshot.docs.some(doc => doc.data().status === 'pending');
                } catch (e) {
                    // Captura errores si el index para 'debtorId' no existe (aunque debería ser un índice simple y seguro)
                    console.error("Fallo al verificar solicitud activa:", e.message);
                    showMessage(`Error al verificar solicitudes: ${e.message}`, 'error');
                    return;
                }
                
                if (hasActiveRequest) {
                    showMessage('Ya tienes una solicitud de préstamo activa. Solo puedes tener una a la vez.', 'error'); 
                    return; 
                }
                // --- FIN DEL FIX ---

                const senderData = await getAccountData(senderId);
                if (!senderData) { showMessage('No se pudo obtener tu información de cuenta.', 'error'); return; }
                
                const rScore = senderData.creditScore.average.toFixed(1);
                const rCount = senderData.creditScore.count;
                
                if (!confirm(`Confirmar Solicitud de Préstamo: $${amount.toFixed(2)} al ${interestRate}% de interés. Tu Score es de ${rScore} ★ (${rCount} votos). ¿Publicar solicitud?`)) {
                    showMessage('Solicitud de préstamo cancelada.', 'info'); 
                    return; 
                }

                // [Lógica para Solicitud de Préstamo (Debt Offer)]
                try {
                    // Colección pública para solicitudes
                    const loanRequestsRef = collection(db, `artifacts/${appId}/loan-requests`);
                    const requestData = { 
                        debtorId: senderId, 
                        debtorName: senderData.name, 
                        amount: amount, 
                        interestRate: interestRate, 
                        status: 'pending', // Pendiente de que un prestamista la acepte
                        timestamp: serverTimestamp(), 
                        creditScoreSnapshot: senderData.creditScore.average,
                        description: description // <<-- Descripción guardada
                    };

                    await addDoc(loanRequestsRef, requestData);
                    showMessage('Solicitud de préstamo publicada con éxito. Esperando a un prestamista.', 'success');
                    switchView('dashboard');
                } catch (e) {
                    console.error("Fallo al publicar solicitud:", e.message);
                    showMessage(`Fallo al publicar la solicitud: ${e.message}`, 'error');
                }
                return;
            }

            // Lógica para Transferencia (transfer) y Oferta de Préstamo (loan)
            
            // NUEVO: Obtener el score del receptor para el check de préstamo
            if (transactionType === 'loan') {
                const recipientData = await getAccountData(recipientId);
                if (!recipientData) { showMessage('ID del receptor no encontrado.', 'error'); return; }
                
                const rScore = recipientData.creditScore.average.toFixed(1);
                const rCount = recipientData.creditScore.count;
                
                // Uso de confirm() como única excepción de diálogo de confirmación de flujo de negocio
                if (!confirm(`El receptor (${recipientData.name}) tiene un Score de ${rScore} ★ (${rCount} votos). ¿Deseas continuar con el préstamo de $${amount.toFixed(2)} al ${interest}%?`)) {
                    showMessage('Oferta de préstamo cancelada por el prestamista.', 'info'); 
                    return; 
                }
            }

            const senderRef = doc(db, `artifacts/${appId}/users/${senderId}/account/data`);
            const recipientRef = doc(db, `artifacts/${appId}/users/${recipientId}/account/data`);

            try {
                const senderData = await getAccountData(senderId);
                const recipientData = await getAccountData(recipientId);

                if (!recipientData) { showMessage('ID del receptor no encontrado.', 'error'); return; }

                // Doble check para Transfer y Loan
                if (transactionType === 'loan') {
                    // Lógica para Oferta de Préstamo (Aún no se mueve el dinero)
                    const loanData = {
                        amount: amount,
                        senderId: senderId,
                        recipientId: recipientId,
                        interestRate: interest,
                        originalAmount: amount,
                        status: 'pending-offer',
                        recipientName: recipientData ? recipientData.name : 'Desconocido',
                        description: description // <<-- Descripción guardada
                    };

                    // Verificar que el remitente tenga saldo para la OFERTA
                    const senderDoc = await getDoc(senderRef);
                    if (!senderDoc.exists() || senderDoc.data().balance < amount) {
                        throw new Error("Saldo insuficiente para enviar la oferta de préstamo.");
                    }

                    // 1. Prestamista (Registra la salida potencial de dinero - tipo: loan-sent)
                    const loanSentDoc = await createTransaction(senderId, { 
                        ...loanData, 
                        type: 'loan-sent', 
                        scoreGiven: false // Nuevo campo para saber si ya se puntuó
                    });

                    // 2. Deudor (Registra la OFERTA que debe ACEPTAR/RECHAZAR - tipo: loan-offer)
                    await createTransaction(recipientId, { 
                        ...loanData, 
                        type: 'loan-offer', 
                        senderTransactionId: loanSentDoc.id,
                        lenderName: senderData ? senderData.name : 'Anónimo'
                    });

                    showMessage('Oferta de préstamo enviada. El receptor debe aceptarla.', 'success');

                } else {
                    // Lógica para Transferencia Directa (Mover dinero inmediatamente)
                    await runTransaction(db, async (transaction) => {
                        const senderDoc = await transaction.get(senderRef);
                        if (!senderDoc.exists()) throw new Error("Documento remitente no existe.");
                        const recipientDoc = await transaction.get(recipientRef);
                        if (!recipientDoc.exists()) throw new Error("Documento receptor no existe. Verifica el ID.");

                        const senderBalance = senderDoc.data().balance;
                        if (senderBalance < amount) throw new Error("Saldo insuficiente.");

                        const newSenderBalance = senderBalance - amount;
                        const newRecipientBalance = recipientDoc.data().balance + amount;

                        transaction.update(senderRef, { balance: newSenderBalance });
                        transaction.update(recipientRef, { balance: newRecipientBalance });
                    });
                    
                    const baseTransferData = { 
                        amount, 
                        senderId, 
                        recipientId, 
                        senderName: senderData ? senderData.name : 'Anónimo', 
                        recipientName: recipientData ? recipientData.name : 'Desconocido',
                        description: description // <<-- Descripción guardada
                    };

                    // Historial del Remitente (Negativo)
                    await createTransaction(senderId, { ...baseTransferData, type: 'transfer-sent' });
                    // Historial del Receptor (Positivo)
                    await createTransaction(recipientId, { ...baseTransferData, type: 'transfer-received' });

                    showMessage('Transferencia exitosa.', 'success');
                }

                switchView('dashboard');
                loadBalance(senderId);

            } catch (e) {
                console.error("Fallo de Transacción: ", e.message);
                showMessage(`Fallo la transferencia: ${e.message}`, 'error');
            }
        });

        // --- REEMBOLSO DE PRÉSTAMO (Pago) CON COMISIÓN BANCARIA ESCALONADA SOBRE EL TOTAL (CORREGIDO) ---
        async function payLoan(loanDocId, loanData) {
            if (!currentUser) return;

            const originalAmount = loanData.originalAmount;
            // Interés en formato decimal (ej: 5% -> 0.05)
            const interestRateDecimal = loanData.interestRate / 100;

            // 1. Cálculo de Montos
            const interestAmount = originalAmount * interestRateDecimal; // Interés bruto
            const amountToPay = originalAmount + interestAmount; // Monto total que paga el deudor (Capital + Interés Bruto)

            // LÓGICA DE COMISIÓN BANCARIA ESCALONADA (Basada en el Monto Original del Préstamo)
            let bankCommissionRate;
            // Comisión: 5% (< $50), 8% ($50 <= x < $250), 10% (>= $250)
            if (originalAmount >= 250) { 
                bankCommissionRate = 0.10; // 10% si >= $250
            } else if (originalAmount >= 50) { 
                bankCommissionRate = 0.08; // 8% si $50 <= Préstamo < $250
            } else {
                bankCommissionRate = 0.05; // 5% si Préstamo < $50
            }
            
            // La comisión se calcula sobre el MONTO TOTAL A PAGAR (Capital + Interés Bruto)
            const bankCommission = amountToPay * bankCommissionRate; // Comisión del banco sobre el TOTAL

            // El prestamista recibe el TOTAL pagado menos la comisión del banco
            const amountLenderReceives = amountToPay - bankCommission;
            
            const payerId = currentUser.uid; // El usuario que paga (el deudor)
            const recipientId = loanData.senderId; // El usuario que recibe (el prestamista original)

            const payerRef = doc(db, `artifacts/${appId}/users/${payerId}/account/data`);
            const recipientRef = doc(db, `artifacts/${appId}/users/${recipientId}/account/data`);
            
            // El documento de deuda que se va a marcar como pagado (es el documento loan-debt del deudor)
            const loanDocRef = doc(db, `artifacts/${appId}/users/${payerId}/transactions/${loanDocId}`);

            // El documento 'loan-sent' del prestamista que se va a marcar como pagado (buscándolo por el senderTransactionId)
            const lenderTransactionId = loanData.senderTransactionId;
            const loanSentDocRef = doc(db, `artifacts/${appId}/users/${recipientId}/transactions/${lenderTransactionId}`);
            
            // El documento de solicitud de préstamo (si existía)
            const loanRequestDocId = loanData.loanRequestDocId; // Asumiendo que este ID existe en loanData

            // 4. Ejecución de la transacción (Mover el dinero y marcar como pagado)
            try {
                await runTransaction(db, async (transaction) => {
                    const payerDoc = await transaction.get(payerRef);
                    if (!payerDoc.exists()) throw new Error("Documento del pagador (deudor) no existe.");
                    const recipientDoc = await transaction.get(recipientRef);
                    if (!recipientDoc.exists()) throw new Error("Documento del prestamista no existe. Verifica el ID.");
                    
                    const payerBalance = payerDoc.data().balance;
                    if (payerBalance < amountToPay) throw new Error("Saldo insuficiente para pagar el préstamo.");

                    const newPayerBalance = payerBalance - amountToPay; 
                    
                    // Saldo del prestamista
                    const recipientBalance = recipientDoc.data().balance;
                    const newRecipientBalance = recipientBalance + amountLenderReceives;

                    // 1. ACTUALIZAR SALDO DEL PAGADOR (Deudor)
                    transaction.update(payerRef, { balance: newPayerBalance });

                    // 2. ACTUALIZAR SALDO DEL RECEPTOR (Prestamista)
                    transaction.update(recipientRef, { balance: newRecipientBalance });

                    // 3. ACTUALIZAR EL DOCUMENTO DE DEUDA DEL DEUDOR (Marcarlo como pagado)
                    transaction.update(loanDocRef, { status: 'completed-paid', paidAmount: amountToPay, paidDate: serverTimestamp() });

                    // 4. ACTUALIZAR EL DOCUMENTO DE PRÉSTAMO DEL PRESTAMISTA (Marcarlo como pagado)
                    // CÓDIGO CORREGIDO DENTRO DE function payLoan
// 4. ACTUALIZAR EL DOCUMENTO DE PRÉSTAMO DEL PRESTAMISTA (Marcarlo como pagado)
                    transaction.update(loanSentDocRef, { status: 'completed-paid', paidAmount: amountToPay, paidDate: serverTimestamp(), scoreGiven: false });
                    
                    // 5. Cancelar la solicitud de préstamo pública si fue aceptada desde una solicitud
                    if (loanRequestDocId) {
                         const loanRequestRef = doc(db, `artifacts/${appId}/loan-requests/${loanRequestDocId}`);
                         transaction.update(loanRequestRef, { status: 'completed-paid', paidDate: serverTimestamp() });
                    }
                });

                // 5. Crear transacciones de historial
                const payerData = await getAccountData(payerId);
                const recipientData = await getAccountData(recipientId);

                 // A. Registrar la comisión bancaria en el historial del deudor (Salida de dinero - Negativo)
                await createTransaction(payerId, {
                    amount: bankCommission,
                    senderId: payerId,
                    recipientId: 'HUG Bank',
                    type: 'bank-commission', // Salida de dinero por comisión (NEGATIVO)
                    originalLoanId: loanDocId,
                    interestRate: loanData.interestRate,
                    senderName: payerData.name,
                    recipientName: 'HUG Bank',
                    description: loanData.description || 'Comisión por pago de préstamo'
                }); 

                 // B. Registrar el pago en el historial del deudor (Solo Historial)
                await createTransaction(payerId, {
                    amount: amountToPay,
                    senderId: payerId,
                    recipientId: recipientId,
                    type: 'loan-payment-sent', // Salida de dinero (Pago de préstamo - Solo Historial)
                    originalLoanId: loanDocId,
                    interestRate: loanData.interestRate,
                    senderName: payerData.name,
                    recipientName: recipientData.name,
                    description: loanData.description || 'Pago de préstamo'
                }); 

                 // C. Registrar el pago en el historial del prestamista (Solo Historial)
                await createTransaction(recipientId, {
                    amount: amountLenderReceives,
                    senderId: payerId,
                    recipientId: recipientId,
                    type: 'loan-payment-received', // Entrada de dinero (Cobro de préstamo - Solo Historial)
                    originalLoanId: lenderTransactionId,
                    interestRate: loanData.interestRate,
                    senderName: payerData.name,
                    recipientName: recipientData.name,
                    description: loanData.description || 'Cobro de préstamo'
                }); 

                showMessage(`Préstamo de $${amountToPay.toFixed(2)} pagado con éxito. El banco cobró $${bankCommission.toFixed(2)} de comisión. ¡Ahora puedes puntuar al deudor!`, 'success');
                loadBalance(payerId);
                listenToTransactions(payerId); // Forzar recarga de transacciones
            } catch (e) {
                console.error("Fallo al pagar el préstamo:", e);
                showMessage(`Fallo al pagar el préstamo: ${e.message}`, 'error');
            }
        }
        
        // --- FUNCIÓN ADICIONAL: Aceptar una oferta de préstamo (CORREGIDO) ---
        async function acceptLoanOffer(debtDocId, debtData) {
             if (!currentUser) return;
             const payerId = debtData.senderId; // El que presta (Prestamista)
             const recipientId = currentUser.uid; // El que acepta (Deudor)
             const amount = debtData.originalAmount;

             const payerRef = doc(db, `artifacts/${appId}/users/${payerId}/account/data`);
             const recipientRef = doc(db, `artifacts/${appId}/users/${recipientId}/account/data`);
             
             // 1. Documento de la OFERTA (loan-offer del deudor)
             const debtDocRef = doc(db, `artifacts/${appId}/users/${recipientId}/transactions/${debtDocId}`);
             // 2. Documento de PRÉSTAMO ENVIADO (loan-sent del prestamista)
             const loanSentDocRef = doc(db, `artifacts/${appId}/users/${payerId}/transactions/${debtData.senderTransactionId}`);
             
             try {
                 await runTransaction(db, async (transaction) => {
                     const payerDoc = await transaction.get(payerRef);
                     if (!payerDoc.exists()) throw new Error("Documento del prestamista no existe.");

                     const payerBalance = payerDoc.data().balance;
                     // Verificar que el prestamista aún tenga el saldo
                     if (payerBalance < amount) throw new Error("El prestamista ya no tiene el saldo disponible para este préstamo.");

                     // Mover dinero
                     const newPayerBalance = payerBalance - amount;
                     const newRecipientBalance = (await transaction.get(recipientRef)).data().balance + amount;
                     
                     // 1. Actualizar saldos
                     transaction.update(payerRef, { balance: newPayerBalance });
                     transaction.update(recipientRef, { balance: newRecipientBalance });
                     
                     // 2. Actualizar estado en el Deudor (Pasa de 'loan-offer' a 'loan-debt')
                     transaction.update(debtDocRef, { 
                         status: 'pending', // De 'pending-offer' a 'pending' deuda
                         type: 'loan-debt', // Tipo: Deuda (cambio de tipo)
                         receivedDate: serverTimestamp() 
                     });

                     // 3. Actualizar estado en el Prestamista (Pasa de 'pending-offer' a 'completed')
                     transaction.update(loanSentDocRef, { 
                         status: 'completed', // De 'pending-offer' a 'completed'
                         sentDate: serverTimestamp() 
                     });
                 });
                 
                 // 4. Crear transacciones de historial
                const payerData = await getAccountData(payerId);
                const recipientData = await getAccountData(recipientId);

                 // A. Historial del Prestamista (Salida de dinero - Solo Historial)
                await createTransaction(payerId, {
                    amount: amount,
                    senderId: payerId,
                    recipientId: recipientId,
                    type: 'loan-disbursed', // Salida de dinero por desembolso
                    originalLoanId: debtData.senderTransactionId,
                    interestRate: debtData.interestRate,
                    senderName: payerData.name,
                    recipientName: recipientData.name,
                    description: debtData.description || 'Desembolso de préstamo'
                }); 

                 // B. Historial del Deudor (Entrada de dinero - Solo Historial)
                await createTransaction(recipientId, {
                    amount: amount,
                    senderId: payerId,
                    recipientId: recipientId,
                    type: 'loan-received', // Entrada de dinero por préstamo
                    originalLoanId: debtDocId,
                    interestRate: debtData.interestRate,
                    senderName: payerData.name,
                    recipientName: recipientData.name,
                    description: debtData.description || 'Recepción de préstamo'
                }); 


                 showMessage('Préstamo aceptado y dinero recibido. ¡Ahora tienes una deuda!', 'success');
                 loadBalance(recipientId); // Recargar saldo del deudor
                 listenToTransactions(recipientId); // Forzar recarga de transacciones
                 
             } catch (e) {
                 console.error("Fallo al aceptar el préstamo:", e);
                 showMessage(`Fallo al aceptar el préstamo: ${e.message}`, 'error');
             }
        }
        
        // --- FUNCIÓN ADICIONAL: Prestar en respuesta a una solicitud pública (CORREGIDO) ---
        async function lendOnRequest(requestDocId, requestData) {
             if (!currentUser) return;
             const lenderId = currentUser.uid; // El que presta (Prestamista)
             const debtorId = requestData.debtorId; // El que solicitó (Deudor)
             const amount = requestData.amount;
             const interest = requestData.interestRate;
             
             const lenderRef = doc(db, `artifacts/${appId}/users/${lenderId}/account/data`);
             const debtorRef = doc(db, `artifacts/${appId}/users/${debtorId}/account/data`);
             const requestDocRef = doc(db, `artifacts/${appId}/loan-requests/${requestDocId}`);
             
             try {
                 let loanSentDocRef;
                 await runTransaction(db, async (transaction) => {
                     const lenderDoc = await transaction.get(lenderRef);
                     if (!lenderDoc.exists()) throw new Error("Documento del prestamista no existe.");

                     const lenderBalance = lenderDoc.data().balance;
                     // Verificar que el prestamista tenga el saldo
                     if (lenderBalance < amount) throw new Error("Saldo insuficiente para conceder el préstamo.");
                     
                     // Verificar que la solicitud siga pendiente
                     const requestDoc = await transaction.get(requestDocRef);
                     if (!requestDoc.exists() || requestDoc.data().status !== 'pending') {
                         throw new Error("La solicitud ya no está disponible o ha sido completada.");
                     }
                     
                     // Crear el documento de deuda en el prestamista DENTRO de la transacción
                     const loanSentRef = collection(db, `artifacts/${appId}/users/${lenderId}/transactions`);
                     const newLoanDoc = await addDoc(loanSentRef, {
                        amount: amount,
                        senderId: lenderId,
                        recipientId: debtorId,
                        interestRate: interest,
                        originalAmount: amount,
                        status: 'completed', // Se marca como completado inmediatamente
                        type: 'loan-sent',
                        sentDate: serverTimestamp(),
                        scoreGiven: false,
                        recipientName: requestData.debtorName,
                        description: requestData.description || 'Préstamo por solicitud pública' // <<-- Descripción guardada
                     });
                     loanSentDocRef = doc(loanSentRef, newLoanDoc.id); // Guardar la referencia completa
                     
                     // Crear el documento de deuda en el deudor DENTRO de la transacción
                     const debtRef = collection(db, `artifacts/${appId}/users/${debtorId}/transactions`);
                     const newDebtDoc = await addDoc(debtRef, {
                        amount: amount,
                        senderId: lenderId,
                        recipientId: debtorId,
                        interestRate: interest,
                        originalAmount: amount,
                        status: 'pending', // Pendiente de pago
                        type: 'loan-debt',
                        receivedDate: serverTimestamp(),
                        senderTransactionId: newLoanDoc.id, // Referencia cruzada
                        lenderName: lenderDoc.data().name,
                        loanRequestDocId: requestDocId, // Referencia a la solicitud pública
                        description: requestData.description || 'Deuda por solicitud pública' // <<-- Descripción guardada
                     });

                     // Mover dinero
                     const newLenderBalance = lenderBalance - amount;
                     const newDebtorBalance = (await transaction.get(debtorRef)).data().balance + amount;
                     
                     // 1. Actualizar saldos
                     transaction.update(lenderRef, { balance: newLenderBalance });
                     transaction.update(debtorRef, { balance: newDebtorBalance });
                     
                     // 2. Marcar la solicitud pública como ACEPTADA/COMPLETADA
                     transaction.update(requestDocRef, { 
                         status: 'accepted',
                         lenderId: lenderId,
                         lenderName: lenderDoc.data().name,
                         loanSentDocId: newLoanDoc.id,
                         loanDebtDocId: newDebtDoc.id,
                         acceptedDate: serverTimestamp()
                     });
                 });
                 
                 // 3. Crear transacciones de historial
                const lenderData = await getAccountData(lenderId);
                const debtorData = await getAccountData(debtorId);

                 // A. Historial del Prestamista (Salida de dinero - Solo Historial)
                await createTransaction(lenderId, {
                    amount: amount,
                    senderId: lenderId,
                    recipientId: debtorId,
                    type: 'loan-disbursed', // Salida de dinero por desembolso
                    originalLoanId: loanSentDocRef.id,
                    interestRate: interest,
                    senderName: lenderData.name,
                    recipientName: debtorData.name,
                    description: requestData.description || 'Desembolso de préstamo (solicitud)'
                }); 

                 // B. Historial del Deudor (Entrada de dinero - Solo Historial)
                await createTransaction(debtorId, {
                    amount: amount,
                    senderId: lenderId,
                    recipientId: debtorId,
                    type: 'loan-received', // Entrada de dinero por préstamo
                    originalLoanId: requestDocRef.id, // Usamos la ref de la solicitud como ID primario para el deudor
                    interestRate: interest,
                    senderName: lenderData.name,
                    recipientName: debtorData.name,
                    description: requestData.description || 'Recepción de préstamo (solicitud)'
                }); 

                 showMessage(`Préstamo de $${amount.toFixed(2)} concedido con éxito. El dinero ha sido transferido al deudor.`, 'success');
                 loadBalance(lenderId);
                 listenToTransactions(lenderId);
                 
             } catch (e) {
                 console.error("Fallo al conceder el préstamo:", e);
                 showMessage(`Fallo al conceder el préstamo: ${e.message}`, 'error');
             }
        }

        // --- MANEJO DE OFERTAS/DEUDAS PENDIENTES ---
        function listenToTransactions(userId) {
            if (!userId) return;

            const transactionsRef = collection(db, `artifacts/${appId}/users/${userId}/transactions`);
            
            // Consulta para Historial Completo (ordenado por fecha)
            const historyQuery = query(transactionsRef, orderBy('timestamp', 'desc'));

            // Consulta para Deudas/Ofertas (solo 'loan-offer' o 'loan-debt' con status 'pending-offer' o 'pending')
            // FIX #1: Se elimina 'orderBy' para evitar el error de índice compuesto de Firestore con la cláusula 'in'.
            const pendingQuery = query(transactionsRef, 
                where('status', 'in', ['pending-offer', 'pending', 'completed', 'completed-paid-penalized']) // Se añade 'completed-paid-penalized' para el nuevo botón de puntuar
            );

            // Listener para el Historial Completo
            onSnapshot(historyQuery, (snapshot) => {
                let html = '';
                if (snapshot.empty) {
                    transactionsList.innerHTML = '<p class="text-gray-500 text-sm text-center">No hay transacciones en el historial.</p>';
                    return;
                }
                
                snapshot.forEach(doc => {
                    html += renderTransactionItem(doc.data(), doc.id, false);
                });
                transactionsList.innerHTML = html;
            }, (error) => {
                 console.error("Error al escuchar historial de transacciones:", error);
                 transactionsList.innerHTML = '<p class="text-red-500 text-sm text-center">Error al cargar el historial.</p>';
            });


            // Listener para Deudas y Ofertas (lista lateral)
            onSnapshot(pendingQuery, (snapshot) => {
                let debtHtml = '';
                if (snapshot.empty) {
                     debtsList.innerHTML = '<p class="text-gray-500 text-sm text-center">No hay deudas u ofertas pendientes.</p>';
                     // No es necesario retornar, solo actualizar la UI
                }

                snapshot.forEach(doc => {
                    const transaction = doc.data();
                    const isPendingOffer = transaction.status === 'pending-offer';
                    const isPendingDebt = transaction.status === 'pending' && transaction.type === 'loan-debt';
                    
                    // Prestamos concedidos (completed), cancelados (completed-paid-penalized) o pagados (completed-paid), que NO han sido puntuados.
                    const isScorePending = (transaction.status === 'completed' || transaction.status === 'completed-paid-penalized' || transaction.status === 'completed-paid') 
                                           && transaction.type === 'loan-sent' 
                                           && transaction.scoreGiven !== true; 
                    
                    if (isPendingOffer || isPendingDebt || isScorePending) {
                       debtHtml += renderTransactionItem(transaction, doc.id, true);
                    }
                });

                if (debtHtml === '') {
                     debtsList.innerHTML = '<p class="text-gray-500 text-sm text-center">No hay deudas u ofertas pendientes.</p>';
                } else {
                    debtsList.innerHTML = debtHtml;
                }
                
                // --- LISTENERS DINÁMICOS ---
                
                // 1. Aceptar Oferta
                debtsList.querySelectorAll('.accept-loan-btn').forEach(button => {
                    button.addEventListener('click', async () => {
                        const docId = button.dataset.id;
                        const docSnap = await getDoc(doc(db, `artifacts/${appId}/users/${userId}/transactions/${docId}`));
                        if (docSnap.exists()) {
                            await acceptLoanOffer(docId, docSnap.data());
                        }
                    });
                });
                
                // 2. Pagar Deuda
                debtsList.querySelectorAll('.pay-debt-btn').forEach(button => {
                    button.addEventListener('click', async () => {
                        const docId = button.dataset.id;
                        const docSnap = await getDoc(doc(db, `artifacts/${appId}/users/${userId}/transactions/${docId}`));
                        if (docSnap.exists()) {
                            // Se muestra diálogo de confirmación en payLoan
                            await payLoan(docId, docSnap.data());
                        }
                    });
                });

                // 3. Marcar como pagado (Cancelar con Penalidad)
                debtsList.querySelectorAll('.cancel-loan-btn').forEach(button => {
                    button.addEventListener('click', async () => {
                        const docId = button.dataset.id; // Doc ID del prestamista (loan-sent)
                        const recipientId = button.dataset.recipient; // ID del deudor
                        
                        if (confirm('ADVERTENCIA: ¿Estás seguro de marcar este préstamo como PAGADO? Se te aplicará una penalidad del 5% de la deuda total en tu saldo. Esto afectará tu balance inmediatamente y podrás puntuar al deudor.')) {
                            await cancelLoanByLender(docId, recipientId);
                        } else {
                            showMessage('Operación abortada.', 'info');
                        }
                    });
                });

                 // 4. Puntuar Deudor (Prestamista)
                debtsList.querySelectorAll('.score-debtor-btn').forEach(button => {
                    button.addEventListener('click', async () => {
                        const loanDocId = button.dataset.id;
                        const recipientId = button.dataset.recipient;
                        const recipientName = button.dataset.recipientname;
                        
                        scoreModal.style.display = 'block';
                        scoreModalRecipientName.textContent = recipientName;
                        scoreModalRecipientId.textContent = recipientId;
                        scoreForm.setAttribute('data-loan-doc-id', loanDocId);
                        scoreForm.setAttribute('data-recipient-id', recipientId);
                        // Resetear el formulario al abrir
                        scoreForm.reset();
                    });
                });
                // --- FIN LISTENERS DINÁMICOS ---

            }, (error) => {
                 // Esta es la parte que captura el error. Dejamos el console.error para debug.
                 console.error("Error al escuchar deudas/ofertas:", error);
                 debtsList.innerHTML = '<p class="text-red-500 text-sm text-center">Error al cargar deudas y ofertas. Intenta recargar la página.</p>';
            });
        }
        

        // --- FUNCIÓN PRINCIPAL PARA RENDERIZAR ELEMENTOS DEL HISTORIAL (CORREGIDA PARA SOPORTAR NUEVOS TIPOS Y DESCRIPCIÓN) ---
        function renderTransactionItem(transaction, docId, isDebtList = true) {
            const amount = transaction.amount || 0;
            const type = transaction.type;
            const senderName = transaction.senderName || 'Anónimo';
            const recipientName = transaction.recipientName || 'Anónimo';
            const interestRate = transaction.interestRate || 0;
            const status = transaction.status || 'N/A';
            const senderIsMe = transaction.senderId === currentUser.uid;
            
            let typeText = 'Transacción';
            let senderRecipientText = '';
            let textColor = 'text-gray-800';
            let borderColor = 'border-gray-200';
            let amountDisplay = `<p class="text-md font-bold text-gray-800">$${amount.toFixed(2)}</p>`;
            let buttonHtml = '';
            let details = '';

            // Convertir el timestamp de Firebase a un string legible
            const date = transaction.timestamp instanceof Object && 'toDate' in transaction.timestamp 
                ? transaction.timestamp.toDate() 
                : (transaction.timestamp ? new Date(transaction.timestamp) : new Date()); // FIX ROBUSTO: Handle potential missing/invalid timestamp
                
            const timestamp = date.toLocaleDateString('es-ES', { 
                year: 'numeric', month: 'short', day: 'numeric', 
                hour: '2-digit', minute: '2-digit' 
            });

            // Lógica por tipo de transacción
            switch (type) {
                case 'transfer-sent':
                    typeText = 'Transferencia Enviada';
                    senderRecipientText = `a ${recipientName}`;
                    textColor = 'text-red-600';
                    borderColor = 'border-red-400';
                    amountDisplay = `<p class="text-md font-bold text-red-600">-$${amount.toFixed(2)}</p>`;
                    break;
                case 'transfer-received':
                    typeText = 'Transferencia Recibida';
                    senderRecipientText = `de ${senderName}`;
                    textColor = 'text-green-600';
                    borderColor = 'border-green-400';
                    amountDisplay = `<p class="text-md font-bold text-green-600">+$${amount.toFixed(2)}</p>`;
                    break;
                case 'loan-offer':
                    typeText = 'Oferta de Préstamo Recibida';
                    senderRecipientText = `de ${senderName}`;
                    textColor = 'text-blue-600';
                    borderColor = 'border-blue-400';
                    
                    if (status === 'pending-offer' && isDebtList) {
                         const amountToPay = amount * (1 + (interestRate / 100));
                         details = `<p class="text-xs text-gray-600">Interés: ${interestRate}%</p>`;
                         amountDisplay = `
                            <p class="text-md font-bold text-gray-800">+$${amount.toFixed(2)}</p>
                            <p class="text-xs text-red-600">Pagar: $${amountToPay.toFixed(2)}</p>`;
                         buttonHtml = `
                            <button class="accept-loan-btn w-full py-1 px-3 rounded-full text-xs font-semibold text-white btn-primary mt-1" data-id="${docId}">Aceptar</button>
                         `;
                    }
                    break;
                case 'loan-sent':
                    typeText = 'Préstamo Enviado (Oferta)';
                    senderRecipientText = `a ${recipientName}`;
                    textColor = 'text-blue-600';
                    borderColor = 'border-blue-400';
                    
                    if (status === 'pending-offer') {
                         details = `<p class="text-xs text-gray-600">Interés: ${interestRate}%</p>`;
                         amountDisplay = `<p class="text-md font-bold text-gray-800">-$${amount.toFixed(2)} (Oferta)</p>`;
                    } else if (status === 'completed') {
                        typeText = 'Préstamo Concedido';
                        const amountToPay = amount * (1 + (interestRate / 100));
                        details = `<p class="text-xs text-gray-600">Interés: ${interestRate}%</p>`;
                        amountDisplay = `
                            <p class="text-md font-bold text-red-600">-$${amount.toFixed(2)} (Capital)</p>
                            <p class="text-xs text-green-600">Cobrar: $${amountToPay.toFixed(2)}</p>
                            <p class="text-xs text-gray-500">Estado: Pendiente de Pago</p>
                        `;
                        // CAMBIO SOLICITADO: Solo mostrar botón de Cancelación/Marcar como pagado
                        if (isDebtList) {
                            buttonHtml = `
                                <button class="cancel-loan-btn w-full py-1 px-3 rounded-full text-xs font-semibold text-white bg-red-500 hover:bg-red-600 transition mt-1" 
                                    data-id="${docId}" data-recipient="${transaction.recipientId}">Marcar como Pagado (5% P.)</button>
                            `;
                        }
                    } else if (status === 'completed-paid') {
                        typeText = 'Préstamo Cobrado';
                        textColor = 'text-green-700';
                        borderColor = 'border-green-500';
                        // El cálculo neto de lo recibido no es trivial en el cliente, se muestra el monto bruto por defecto
                        amountDisplay = `<p class="text-md font-bold text-green-700">+$${(transaction.paidAmount || 0).toFixed(2)}</p>`;
                        details = `<p class="text-xs text-gray-600">Pagado el: ${new Date(transaction.paidDate.toDate()).toLocaleDateString('es-ES')}</p>`;
                    } else if (status === 'completed-paid-penalized') {
                        typeText = 'Préstamo Cancelado (Penalizado)';
                        textColor = 'text-yellow-700';
                        borderColor = 'border-yellow-500';
                         const amountReceived = transaction.paidAmount - transaction.penaltyAmount;
                         amountDisplay = `<p class="text-md font-bold text-yellow-700">+$${amountReceived.toFixed(2)} (Neto)</p>`;
                         details = `<p class="text-xs text-gray-600">Penalidad: $${transaction.penaltyAmount.toFixed(2)}</p>`;
                    }
                    
                    // Botón de Puntuar: Aparece si está pagado o penalizado, y no ha sido puntuado
                    if (isDebtList && (status === 'completed-paid-penalized' || status === 'completed-paid') && transaction.scoreGiven !== true) {
                         buttonHtml += `
                            <button class="score-debtor-btn w-full py-1 px-3 rounded-full text-xs font-semibold text-white bg-green-500 hover:bg-green-600 transition mt-1" 
                                data-id="${docId}" data-recipient="${transaction.recipientId}" data-recipientname="${recipientName}">Puntuar</button>
                         `;
                    }
                    
                    break;
                case 'loan-debt':
                    typeText = 'Deuda Pendiente';
                    senderRecipientText = `con ${senderName}`;
                    textColor = 'text-red-700';
                    borderColor = 'border-red-500';
                    const amountToPay = transaction.originalAmount * (1 + (interestRate / 100));
                    details = `<p class="text-xs text-gray-600">Interés: ${interestRate}%</p>`;
                    
                    if (status === 'pending') {
                         amountDisplay = `
                            <p class="text-md font-bold text-green-600">+$${transaction.originalAmount.toFixed(2)} (Capital)</p>
                            <p class="text-xs text-red-600">Pagar: $${amountToPay.toFixed(2)}</p>
                        `;
                        if (isDebtList) {
                            buttonHtml = `<button class="pay-debt-btn w-full py-1 px-3 rounded-full text-xs font-semibold text-white bg-red-500 hover:bg-red-600 transition mt-1" data-id="${docId}">Pagar $${amountToPay.toFixed(2)}</button>`;
                        }
                    } else if (status === 'completed-paid') {
                        typeText = 'Deuda Pagada';
                        textColor = 'text-green-700';
                        borderColor = 'border-green-500';
                        amountDisplay = `<p class="text-md font-bold text-red-700">-$${amountToPay.toFixed(2)}</p>`;
                        details = `<p class="text-xs text-gray-600">Pagado el: ${new Date(transaction.paidDate.toDate()).toLocaleDateString('es-ES')}</p>`;
                    } else if (status === 'paid-by-lender') {
                        // El deudor ve su deuda marcada como pagada por el prestamista (Cancelación)
                        typeText = 'Deuda Pagada (Cancelación)';
                        textColor = 'text-green-700';
                        borderColor = 'border-green-500';
                        amountDisplay = `<p class="text-md font-bold text-red-700">-$${amountToPay.toFixed(2)}</p>`;
                        details = `<p class="text-xs text-gray-600 font-semibold">Marcada como Pagada por ${senderName}</p>`;
                    }
                    break;
                // --- NUEVOS TIPOS DE HISTORIAL (Solo historial, no aparecen en 'Deudas y Ofertas') ---
                case 'loan-disbursed': // Prestamista cuando el deudor acepta una oferta o solicitud
                    typeText = 'Desembolso Préstamo';
                    senderRecipientText = `a ${recipientName}`;
                    textColor = 'text-red-600';
                    amountDisplay = `<p class="text-md font-bold text-red-600">-$${amount.toFixed(2)}</p>`;
                    details = `<p class="text-xs text-gray-600">Interés: ${interestRate}%</p>`;
                    break;
                case 'loan-received': // Deudor cuando recibe el préstamo
                    typeText = 'Préstamo Recibido';
                    senderRecipientText = `de ${senderName}`;
                    textColor = 'text-green-600';
                    amountDisplay = `<p class="text-md font-bold text-green-600">+$${amount.toFixed(2)}</p>`;
                    details = `<p class="text-xs text-gray-600">Interés: ${interestRate}%</p>`;
                    break;
                case 'loan-payment-sent': // Pago total de la deuda por el deudor (historial)
                     typeText = 'Pago de Deuda Total';
                     senderRecipientText = `a ${recipientName}`;
                     textColor = 'text-red-800';
                     amountDisplay = `<p class="text-md font-bold text-red-800">-$${amount.toFixed(2)}</p>`;
                     details = `<p class="text-xs text-gray-600">Interés: ${interestRate}%</p>`;
                     break;
                case 'loan-payment-received': // Cobro total de la deuda por el prestamista (historial)
                     typeText = 'Cobro de Préstamo (Neto)';
                     senderRecipientText = `de ${senderName}`;
                     textColor = 'text-green-800';
                     amountDisplay = `<p class="text-md font-bold text-green-800">+$${amount.toFixed(2)}</p>`;
                     details = `<p class="text-xs text-gray-600">Interés: ${interestRate}%</p>`;
                     break;
                 case 'bank-commission':
                    typeText = 'Comisión Bancaria';
                    senderRecipientText = 'HUG Bank';
                    textColor = 'text-orange-600';
                    borderColor = 'border-orange-400';
                    amountDisplay = `<p class="text-md font-bold text-red-600">-$${amount.toFixed(2)}</p>`;
                    break;
                 case 'score-reset-fee':
                    typeText = 'Comisión Reset Score';
                    senderRecipientText = 'HUG Bank';
                    textColor = 'text-orange-600';
                    borderColor = 'border-orange-400';
                    amountDisplay = `<p class="text-md font-bold text-red-600">-$${amount.toFixed(2)}</p>`;
                    break;
                 case 'loan-paid-cancellation':
                    typeText = 'Cobro por Cancelación';
                    senderRecipientText = `de ${senderName}`;
                    textColor = 'text-yellow-600';
                    borderColor = 'border-yellow-400';
                    amountDisplay = `<p class="text-md font-bold text-yellow-600">+$${amount.toFixed(2)} (Bruto)</p>`;
                    break;
                 case 'lender-cancellation-penalty':
                    typeText = 'Penalidad por Cancelación';
                    senderRecipientText = 'HUG Bank';
                    textColor = 'text-red-800';
                    borderColor = 'border-red-500';
                    amountDisplay = `<p class="text-md font-bold text-red-800">-$${amount.toFixed(2)}</p>`;
                    break;
                default:
                    // FIX #3: Transacciones desconocidas con signo + o -
                    typeText = ``;
                    textColor = 'text-gray-500';
                    borderColor = 'border-blue-500';
                    
                    if (senderIsMe) {
                        amountDisplay = `<p class="text-md font-bold text-red-600">-$${amount.toFixed(2)}</p>`;
                    } else {
                        amountDisplay = `<p class="text-md font-bold text-gray-500">$${amount.toFixed(2)}</p>`;
                    }
                    break;
            }

            // FIX #2 y SOLICITUD ADICIONAL: Usar la descripción como título principal y limpiar "Transacción Desconocida"
            let mainTitle = transaction.description && transaction.description.length > 0
                ? transaction.description
                : `${typeText} ${senderRecipientText}`;

            // La información secundaria ahora incluye el tipo si se usó la descripción como título.
            // Si es Transacción Desconocida, y hay descripción, no mostramos el texto secundario para limpiar.
            let secondaryTypeHtml = '';
            if (transaction.description && transaction.description.length > 0) {
                 if (type === 'unknown' || type === 'default') {
                    // Si es desconocida Y tiene descripción, NO mostramos info secundaria para limpiar.
                    secondaryTypeHtml = '';
                 } else {
                    // Si tiene descripción y es un tipo conocido, mostramos el tipo como secundario.
                    secondaryTypeHtml = `<p class="text-xs text-gray-600">${typeText} ${senderRecipientText}</p>`;
                 }
            }


            return `
                <div class="transaction-item flex items-center justify-between p-3 rounded-lg border-l-4 ${borderColor} bg-white hover:bg-gray-50 transition duration-150">
                    <div class="flex-grow">
                        <p class="text-sm font-semibold ${textColor}">${mainTitle}</p>
                        ${secondaryTypeHtml} 
                        <p class="text-xs text-gray-500 mt-0.5">${timestamp}</p>
                        ${details}
                    </div>
                    <div class="flex-shrink-0 space-y-1 text-right">
                        ${amountDisplay}
                        ${buttonHtml}
                    </div>
                </div>
            `;
        }
        
        // [ADICIÓN: Función para escuchar Solicitudes de Préstamo]
        function listenToLoanRequests(userId) {
    if (!userId) return;

    // 1. Consulta SIMPLE en Firestore
    // Solo filtra por el estado 'pending', lo cual es un filtro simple que no requiere índice compuesto.
    const q = query(
        collection(db, `artifacts/${appId}/loan-requests`),
        where('status', '==', 'pending') 
        // Opcional: puedes añadir un orderBy() simple aquí, si es necesario, 
        // por ejemplo: orderBy('timestamp', 'desc')
    );

    onSnapshot(q, (querySnapshot) => {
        loanRequestsList.innerHTML = '';
        
        const currentUserId = userId; 
        
        // 2. LÍNEA CLAVE: FILTRADO en el lado del cliente (JavaScript)
        // Crea un nuevo array que excluye las solicitudes donde el 'debtorId' es el del usuario logueado.
        const filteredRequests = querySnapshot.docs.filter(doc => {
            return doc.data().debtorId !== currentUserId;
        });

        if (filteredRequests.length === 0) {
            loanRequestsList.innerHTML = '<p class="text-gray-500 text-sm text-center">No hay solicitudes de préstamo activas en este momento.</p>';
            return;
        }

        // 3. Iteramos sobre el arreglo ya filtrado (filteredRequests)
        filteredRequests.forEach((doc) => { 
            const requestDocId = doc.id;
            const requestData = doc.data();
            
            // Lógica para mostrar las estrellas del Credit Score
            const score = requestData.creditScoreSnapshot || 5.0;
            const starHtml = Array(Math.round(score)).fill('★').join('') + 
                             Array(5 - Math.round(score)).fill('☆').join('');

            const item = document.createElement('li');
            item.className = 'bg-gray-50 p-3 rounded-lg border border-gray-200';
            item.innerHTML = `
                <div class="flex justify-between items-start">
                    <div>
                        <p class="font-bold text-lg text-red-600">$${requestData.amount.toFixed(2)}</p>
                        <p class="text-xs text-gray-500">Deudor: ${requestData.debtorName}</p>
                        <p class="text-xs text-gray-500 break-all">ID: ${requestData.debtorId}</p>
                        <p class="text-xs text-blue-600 mt-1">${requestData.description || 'Sin descripción'}</p>
                    </div>
                    <div class="text-right">
                        <p class="text-sm font-semibold text-green-700">${requestData.interestRate.toFixed(2)}% Int.</p>
                        <p class="text-xs text-yellow-500 mt-1" title="Score de Crédito">${starHtml} (${score.toFixed(1)})</p>
                    </div>
                </div>
                <button class="lend-on-request-btn mt-3 w-full py-2 px-4 rounded-full text-md font-semibold text-white btn-primary"
                        data-id="${requestDocId}">
                    Aceptar Solicitud y Prestar
                </button>
            `;
            
            loanRequestsList.appendChild(item);
        });
        
        // Listener para Aceptar Oferta (Prestar)
        loanRequestsList.querySelectorAll('.lend-on-request-btn').forEach(button => {
            button.addEventListener('click', async () => {
                const docId = button.dataset.id;
                const requestDoc = await getDoc(doc(db, `artifacts/${appId}/loan-requests/${docId}`));
                if (requestDoc.exists()) {
                    // Se muestra diálogo de confirmación en lendOnRequest
                    await lendOnRequest(docId, requestDoc.data());
                }
            });
        });
    });
}
        // [/ADICIÓN: Función para escuchar Solicitudes de Préstamo]
    </script>
</body>
</html>
